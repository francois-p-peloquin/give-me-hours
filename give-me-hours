#!/bin/bash

# give-me-hours.sh - Calculate working hours from git commits across multiple repositories
# Combines git-hours functionality with folder iteration and output formatting

set -e

# Default values for git-hours functionality
DURATION=3600  # 1 hour in seconds
DEBUG=false

# Default values for folder iteration
OUTPUT_TO_FILE=false
SUMMARY_MODE=false
SUMMARY_WORDS=200
GIT_NAME=$(git config --global user.name 2>/dev/null || echo "")

# Helper functions for git-hours
show_help() {
    cat << EOF
give-me-hours.sh - Calculate working hours from git commits across multiple repositories

Usage: give-me-hours.sh [today|yesterday|YYYY-MM-DD] [--file] [--help] [--debug] [-d DURATION] [--summary] [-w WORDS]

Date Options:
    today (default)      - Get hours for today
    yesterday           - Get hours for yesterday
    YYYY-MM-DD          - Get hours for specific date

Output Options:
    --file              - Write output to CSV file (default: console table)
    --help              - Show this help message
    --debug             - Show detailed commit information
    -d, --duration      - Maximum gap between commits (default: 1h)
    --summary           - Generate summary of commit messages
    -w, --words         - Maximum words in summary (default: 200)

Examples:
    give-me-hours.sh
    give-me-hours.sh yesterday --file
    give-me-hours.sh 2024-01-15 --debug
    give-me-hours.sh today --file -d 0.5h
    give-me-hours.sh today --summary
    give-me-hours.sh yesterday --summary -w 150

Duration formats:
    1h, 2h              - hours
    30m, 45m            - minutes
    90s, 120s           - seconds
    0.5h                - decimal hours
EOF
}

get_timezone_offset() {
    date "+%z"
}

parse_duration() {
    local duration_str="$1"
    local value
    local unit

    if [[ $duration_str =~ ^([0-9]*\.?[0-9]+)([hms]?)$ ]]; then
        value="${BASH_REMATCH[1]}"
        unit="${BASH_REMATCH[2]}"

        case "$unit" in
            "h"|"")
                echo "$(echo "$value * 3600" | bc -l | cut -d. -f1)"
                ;;
            "m")
                echo "$(echo "$value * 60" | bc -l | cut -d. -f1)"
                ;;
            "s")
                echo "$(echo "$value" | cut -d. -f1)"
                ;;
        esac
    else
        echo "3600"  # default to 1 hour
    fi
}

date_to_timestamp() {
    local date_str="$1"

    if command -v gdate >/dev/null 2>&1; then
        gdate -d "$date_str" +%s
    else
        date -d "$date_str" +%s
    fi
}

timestamp_to_date() {
    local timestamp="$1"

    if command -v gdate >/dev/null 2>&1; then
        gdate -d "@$timestamp" "+%Y-%m-%d %H:%M:%S %z"
    else
        date -d "@$timestamp" "+%Y-%m-%d %H:%M:%S %z"
    fi
}

format_duration() {
    local seconds="$1"
    local hours=$((seconds / 3600))
    local minutes=$(((seconds % 3600) / 60))
    local secs=$((seconds % 60))

    local result=""

    if [ $hours -gt 0 ]; then
        result="${result}${hours}h"
    fi

    if [ $minutes -gt 0 ]; then
        result="${result}${minutes}m"
    fi

    if [ $secs -gt 0 ] || [ -z "$result" ]; then
        result="${result}${secs}s"
    fi

    echo "$result"
}

build_git_command() {
    local since="$1"
    local before="$2"
    local author="$3"

    local cmd="git log --pretty=format:'%at|%an|%s' --reverse"

    # Add date range
    cmd="$cmd --since=\"$since\" --before=\"$before\""

    # Add author filter if specified
    if [ -n "$author" ]; then
        cmd="$cmd --author=\"$author\""
    fi

    echo "$cmd"
}

get_git_commits() {
    local since="$1"
    local before="$2"
    local author="$3"
    local cmd

    cmd=$(build_git_command "$since" "$before" "$author")

    if [ "$DEBUG" = true ]; then
        echo "Running: $cmd" >&2
    fi

    eval "$cmd" 2>/dev/null || return 1
}

calculate_working_hours() {
    local total_seconds=0
    local prev_timestamp=""
    local prev_author=""
    local prev_message=""
    local line_count=0

    while IFS='|' read -r timestamp author message; do
        # Skip empty lines
        [ -z "$timestamp" ] && continue

        line_count=$((line_count + 1))

        if [ -n "$prev_timestamp" ]; then
            local interval=$((timestamp - prev_timestamp))

            if [ "$DEBUG" = true ]; then
                echo "$(timestamp_to_date "$prev_timestamp") $prev_author $prev_message" >&2
                echo "$(format_duration "$interval") >" >&2
            fi

            # Only count time if interval is less than duration threshold
            if [ $interval -le $DURATION ]; then
                total_seconds=$((total_seconds + interval))
            fi
        fi

        prev_timestamp="$timestamp"
        prev_author="$author"
        prev_message="$message"
    done

    # Print the last commit in debug mode
    if [ "$DEBUG" = true ] && [ -n "$prev_timestamp" ]; then
        echo "$(timestamp_to_date "$prev_timestamp") $prev_author $prev_message" >&2
    fi

    echo "$total_seconds"
}

get_hours_for_repo() {
    local since="$1"
    local before="$2"
    local author="$3"

    # Check if we're in a git repository
    if ! git rev-parse --git-dir >/dev/null 2>&1; then
        return 1
    fi

    # Get commits and calculate working hours
    local commits_output
    commits_output=$(get_git_commits "$since" "$before" "$author")

    if [ -z "$commits_output" ]; then
        echo "0"
        return 0
    fi

    local total_seconds
    total_seconds=$(echo "$commits_output" | calculate_working_hours)

    echo "$total_seconds"
}

write_output() {
    local content="$1"
    local header="$2"

    if [ "$OUTPUT_TO_FILE" = true ]; then
        if [ "$header" = true ]; then
            echo "$content" > "$OUTPUT_FILE"
        else
            echo "$content" >> "$OUTPUT_FILE"
        fi
    else
        if [ "$header" = true ]; then
            echo "$content" > /tmp/give_me_hours_data.csv
        else
            echo "$content" >> /tmp/give_me_hours_data.csv
        fi
    fi
}

# Check for required commands
for cmd in bc; do
    if ! command -v "$cmd" >/dev/null 2>&1; then
        echo "Error: Required command '$cmd' not found" >&2
        echo "Please install it using your system's package manager" >&2
        exit 1
    fi
done

# Check if the username was retrieved successfully
if [ -z "$GIT_NAME" ]; then
    echo "Error: Git global username is not set" >&2
    echo "Set it with: git config --global user.name 'Your Name'" >&2
    exit 1
fi

echo "Git username: $GIT_NAME"

# Parse command line arguments
DATE_ARG=""
while [[ $# -gt 0 ]]; do
    case $1 in
        --help)
            show_help
            exit 0
            ;;
        --file)
            OUTPUT_TO_FILE=true
            shift
            ;;
        --debug)
            DEBUG=true
            shift
            ;;
        -d|--duration)
            DURATION=$(parse_duration "$2")
            shift 2
            ;;
        --summary)
            SUMMARY_MODE=true
            shift
            ;;
        -w|--words)
            SUMMARY_WORDS="$2"
            shift 2
            ;;
        today|yesterday)
            DATE_ARG="$1"
            shift
            ;;
        [0-9][0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9])
            DATE_ARG="$1"
            shift
            ;;
        *)
            echo "Unknown option: $1" >&2
            echo "Use --help for usage information" >&2
            exit 1
            ;;
    esac
done

# Default to today if no date specified
if [ -z "$DATE_ARG" ]; then
    DATE_ARG="today"
fi

# Set date range based on parameter
case "$DATE_ARG" in
    "today")
        START_DATE=$(date "+%Y-%m-%d 00:00:00")
        END_DATE=$(date "+%Y-%m-%d 23:59:59")
        OUTPUT_FILE="give_me_hours__worked_today.csv"
        ;;
    "yesterday")
        if command -v gdate >/dev/null 2>&1; then
            # macOS with GNU coreutils
            START_DATE=$(gdate -d "yesterday" "+%Y-%m-%d 00:00:00")
            END_DATE=$(gdate -d "yesterday" "+%Y-%m-%d 23:59:59")
        elif date -v-1d >/dev/null 2>&1; then
            # macOS native date
            START_DATE=$(date -v-1d "+%Y-%m-%d 00:00:00")
            END_DATE=$(date -v-1d "+%Y-%m-%d 23:59:59")
        else
            # Linux date
            START_DATE=$(date -d "yesterday" "+%Y-%m-%d 00:00:00")
            END_DATE=$(date -d "yesterday" "+%Y-%m-%d 23:59:59")
        fi
        OUTPUT_FILE="give_me_hours__worked_yesterday.csv"
        ;;
    *)
        # Check if date format is valid
        if [[ ! "$DATE_ARG" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}$ ]]; then
            echo "Error: Invalid date format. Please use YYYY-MM-DD" >&2
            show_help
            exit 1
        fi
        START_DATE="$DATE_ARG 00:00:00"
        END_DATE="$DATE_ARG 23:59:59"
        OUTPUT_FILE="give_me_hours__worked_${DATE_ARG}.csv"
        ;;
esac

echo ""
echo "Getting hours from $START_DATE to $END_DATE"
if [ "$DEBUG" = true ]; then
    echo "Duration threshold: $(format_duration "$DURATION")"
fi
echo ""

# Create the CSV header
if [ "$SUMMARY_MODE" = true ]; then
    write_output "Folder,Hours,Summary" true
else
    write_output "Folder,Hours" true
fi

# Keep track of total hours
total_hours_seconds=0
repos_found=0
all_commit_messages=""

# Find the lib directory once at the start if in summary mode
GLOBAL_LIB_DIR=""
if [ "$SUMMARY_MODE" = true ]; then
    SCRIPT_PATH="$(readlink -f "$0" 2>/dev/null || realpath "$0" 2>/dev/null || echo "$0")"
    SCRIPT_DIR="$(dirname "$SCRIPT_PATH")"
    
    # Check locations where lib might be installed
    for potential_lib in "$SCRIPT_DIR/lib" "$SCRIPT_DIR/../lib" "/usr/local/lib/give-me-hours" "/opt/homebrew/lib/give-me-hours" "$(dirname "$0")/lib"; do
        if [ -n "$potential_lib" ] && [ -f "$potential_lib/summary.js" ]; then
            GLOBAL_LIB_DIR="$potential_lib"
            break
        fi
    done
fi

# Loop through all subdirectories that are git repositories
for dir in $(find . -maxdepth 1 -type d -not -path "*/\.*" | sort); do
    if [ -d "$dir/.git" ]; then
        repos_found=$((repos_found + 1))
        cd "$dir"

        if [ "$DEBUG" = true ]; then
            echo "=== Processing repository: ${dir#./} ===" >&2
        fi

        # Get working hours for this repository
        hours_seconds=$(get_hours_for_repo "$START_DATE" "$END_DATE" "$GIT_NAME")

        # Get commit messages for this repository if in summary mode  
        repo_summary=""
        if [ "$SUMMARY_MODE" = true ]; then
            repo_commits=$(get_git_commits "$START_DATE" "$END_DATE" "$GIT_NAME" | cut -d'|' -f3)
            if [ -n "$repo_commits" ]; then
                all_commit_messages="$all_commit_messages$repo_commits"$'\n'
                
                # Generate summary for this specific repository using global lib dir
                if command -v node >/dev/null 2>&1 && [ -n "$GLOBAL_LIB_DIR" ] && [ -f "$GLOBAL_LIB_DIR/summary.js" ]; then
                    repo_summary=$(echo "$repo_commits" | node "$GLOBAL_LIB_DIR/summary.js" -w "$SUMMARY_WORDS" 2>/dev/null || echo "Error generating summary")
                    # Remove commas and newlines from summary for CSV compatibility
                    repo_summary=$(echo "$repo_summary" | tr ',' ';' | tr '\n' ' ')
                else
                    repo_summary="Summary unavailable"
                fi
            else
                repo_summary="No commits"
            fi
        fi

        # Add to output if hours were worked (more than 0 seconds)
        if [ "$hours_seconds" -gt 0 ]; then
            hours_formatted=$(format_duration "$hours_seconds")
            total_hours_seconds=$((total_hours_seconds + hours_seconds))

            cd ..
            if [ "$SUMMARY_MODE" = true ]; then
                write_output "${dir#./},$hours_formatted,\"$repo_summary\"" false
            else
                write_output "${dir#./},$hours_formatted" false
            fi

            if [ "$DEBUG" = true ]; then
                echo "Found $(format_duration "$hours_seconds") in ${dir#./}" >&2
            fi
        else
            cd ..
            if [ "$DEBUG" = true ]; then
                echo "No hours found in ${dir#./}" >&2
            fi
        fi

        if [ "$DEBUG" = true ]; then
            echo "" >&2
        fi
    fi
done

if [ $repos_found -eq 0 ]; then
    echo "No git repositories found in current directory"
    exit 0
fi

# Add total row
if [ $total_hours_seconds -gt 0 ]; then
    total_formatted=$(format_duration "$total_hours_seconds")
    if [ "$SUMMARY_MODE" = true ]; then
        write_output "────────────────────────────────────────,─────────────────,────────────────────────────────────────" false
        # Generate overall summary using global lib dir
        overall_summary=""
        if [ -n "$all_commit_messages" ] && command -v node >/dev/null 2>&1 && [ -n "$GLOBAL_LIB_DIR" ] && [ -f "$GLOBAL_LIB_DIR/summary.js" ]; then
            overall_summary=$(echo "$all_commit_messages" | node "$GLOBAL_LIB_DIR/summary.js" -w "$SUMMARY_WORDS" 2>/dev/null || echo "Error generating summary")
            overall_summary=$(echo "$overall_summary" | tr ',' ';' | tr '\n' ' ')
        else
            overall_summary="Overall summary unavailable"
        fi
        write_output "TOTAL,$total_formatted,\"$overall_summary\"" false
    else
        write_output "────────────────────────────────────────,─────────────────" false
        write_output "TOTAL,$total_formatted" false
    fi
fi

if [ "$OUTPUT_TO_FILE" = true ]; then
    echo "Hours saved to $OUTPUT_FILE"
    echo "Total hours worked: $(format_duration "$total_hours_seconds")"
else
    echo "Found $repos_found git repositories"
    echo ""

    # Display results in a nice table format
    if [ "$SUMMARY_MODE" = true ]; then
        awk -F, '{
            if (NR==1) {
                printf "┌──────────────────────────────────────────┬─────────────────┬──────────────────────────────────────────┐\n"
                printf "│ %-40s │ %-15s │ %-40s │\n", $1, $2, $3;
                printf "├──────────────────────────────────────────┼─────────────────┼──────────────────────────────────────────┤"
            } else if ($1 ~ /^─+$/) {
                # This is a separator line - render as table separator
                printf "\n├──────────────────────────────────────────┼─────────────────┼──────────────────────────────────────────┤"
            } else {
                # Handle quoted fields by removing quotes and truncating summary
                gsub(/"/, "", $3)
                summary = $3
                if (length(summary) > 40) {
                    summary = substr(summary, 1, 37) "..."
                }
                printf "\n│ %-40s │ %-15s │ %-40s │", $1, $2, summary
            }
        } END { 
            print "\n└──────────────────────────────────────────┴─────────────────┴──────────────────────────────────────────┘" 
        }' /tmp/give_me_hours_data.csv
    else
        awk -F, '{
            if (NR==1) {
                printf "┌──────────────────────────────────────────┬─────────────────┐\n"
                printf "│ %-40s │ %-15s │\n", $1, $2;
                printf "├──────────────────────────────────────────┼─────────────────┤"
            } else if ($1 ~ /^─+$/) {
                # This is a separator line - render as table separator
                printf "\n├──────────────────────────────────────────┼─────────────────┤"
            } else {
                printf "\n│ %-40s │ %-15s │", $1, $2
            }
        } END { 
            print "\n└──────────────────────────────────────────┴─────────────────┘" 
        }' /tmp/give_me_hours_data.csv
    fi

    echo ""
    echo "Total hours worked: $(format_duration "$total_hours_seconds")"

    # Clean up temporary file
    rm -f /tmp/give_me_hours_data.csv
fi
